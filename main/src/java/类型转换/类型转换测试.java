package 类型转换;

public class 类型转换测试 {

	public static void main(String[] args) {
		// 首先基本的整数int，小数double这些就不扯了

		// 1:final类型变量不参与自动类型变换（类型提升）。
		int a = 1;
		byte b = 2;// 注意虽然int转byte是需要强制转换的，但是字面类型的int是直接可以赋值给byte的。但注意byte范围
		// byte bbbb = 128;//编译出错
		// 对于int变量因为编译时期无法确定大小，所以是不允许的，必须强转。
		byte c = 3;
		byte d = 4;
		a = b;// 类型提升，编译运行正确
		// b = a; // 类型下降，编译出错。
		// d=b+c;//类型完全一致，但是b+c的运算会转换为int，所以变为类型下降，编译出错。
		d = (byte) (b + c);// 强转即可

		final byte e = 5;
		final byte f = 6;
		d = e + f;// 正确，因为e和f都是final类型，所以运算也不会改变为int

		// 下面说明关于强制类型转换的一个语法
		// 一定要注意：正确的语法是 括号内加要被转换为的类型
		// 这个括号是必须的，没有这个括号，就编译通不过
		// 对于被强制转换的变量如果是表达式，可以再次使用括号括起来
		// 但前边那个用于类型转换的括号是必须必须必须的！！！！！！！！！！！！！
		int aa = 1;
		byte bb = 2;
		aa = (int) (bb);

		int cc = 'a';
		char char0 = 'b';
		cc = char0;
		cc = 'c';
		char0 = (char) cc;
		System.out.println(char0);

		System.out.println(Math.round(10.5));// 11
		System.out.println(Math.round(-10.5));// -10
		System.out.println(Math.round(-10.4));// -10
		System.out.println(Math.round(-10.6));// -11

		long ll = 12;
		// Long ll2 = 12; // 错误
		float ff = 12;
		float ff2 = 12F;
		// Float ff3 = 12;//错误

		// 注意基本类型的float，double，long类型等等都可以直接使用int字面类型或int赋值
		int iii = 3;
		ll = iii;
		ff = iii;
		ff2 = iii;
		// Float ff4 = iii;//错误

	}

	/***
	 * char,short,int,long,float,double 总结：
	 * 
	 * 字面量的范围等价于int的范围（4字节带符号位）
	 * 
	 * char，short，int，long，float，double都支持字面量直接赋值（不需要强制类型转换）
	 * 
	 * 但是要注意数据范围，比如char和short。
	 * 
	 * long，float，double的话超出int部分依然可以使用字面量，但是需要加L，F，D作为后缀。 换句话说，字面量默认是int类型，按照int的范围来限制编译。
	 * 
	 */
	public void 使用字面量赋值() {
		// char（正数；无符号双字节）
		char 字符最小 = 0;
		char 字符最大 = 65535;
		// short（有符号双字节）
		short 短整型最小 = -32768;
		short 短整型最大 = 32767;
		// int（有符号四个字节）
		int 整型最小 = Integer.MIN_VALUE;// 0x80000000 == -2147483648
		int 整型最大 = Integer.MAX_VALUE;// 0x7fffffff == 2147483647
		// 注意搞清楚负数的表达方式
		System.out.println(0x80_00_00_00);// 去掉符号为，取反加一得到2147483648（注意加一之后会溢出到符号位，这个无所谓）
		System.out.println(0x80_00_00_01);// 去掉符号为，取反加一得到2147483647
		System.out.println(0xff_ff_ff_ff);
		// long（注意long类型依然可以直接使用int字面量直接赋值，但是超过int范围部分是需要加L尾缀的）
		// 换句话说，字面量的范围等价于有符号整型数的范围
		long 长整型最小 = 0x8000000000000000L;
		long 长整型最大 = 0x7fffffffffffffffL;
		// float
		float 单精度浮点数最小 = Float.MIN_VALUE;
		// double
		double 双精度浮点数最小 = Double.MIN_VALUE;
		float f1 = 123;
		float f2 = 123L;
		float f3 = 2147483648F;
		double d1 = f1;
		double d2 = 123;
		double d3 = 123F;
		double d4 = 2147483648F;
		double d5 = 2147483648D;

	}

	/***
	 * 基本类型直接转换(变量，不考虑字面量)
	 * 
	 * 低精度变量 = 高精度变量 （必须强制转换）
	 * 
	 * 高精度变量 = 低精度变量 （不需要强制转换）
	 * 
	 */
	public void 基本数据类型转换() {
		char 字符型基本数据 = ' ';
		short 短整型基本数据 = 48;
		int 整型基本数据 = 48;
		long 长整型基本数据 = 48;
		float 单精度浮点 = 1.2F;
		double 双精度浮点 = 2.4;

		字符型基本数据 = 字符型基本数据;
		// 短整型基本数据 = 字符型基本数据; //需要强制转换（char是双字节无符号，而short是双字节带符号。符号以及数据范围都有差距，无法默认转换）
		整型基本数据 = 字符型基本数据;
		长整型基本数据 = 字符型基本数据;
		单精度浮点 = 字符型基本数据;
		双精度浮点 = 字符型基本数据;

		// 字符型基本数据 = 短整型基本数据;
		短整型基本数据 = 短整型基本数据;
		整型基本数据 = 短整型基本数据;
		长整型基本数据 = 短整型基本数据;
		单精度浮点 = 短整型基本数据;
		双精度浮点 = 短整型基本数据;

		// 字符型基本数据 = 长整型基本数据;
		// 短整型基本数据 = 长整型基本数据;
		// 整型基本数据 = 长整型基本数据;
		长整型基本数据 = 长整型基本数据;
		单精度浮点 = 长整型基本数据;
		双精度浮点 = 长整型基本数据;

		// 字符型基本数据 = 单精度浮点;
		// 短整型基本数据 = 单精度浮点;
		// 整型基本数据 = 单精度浮点;
		// 长整型基本数据 = 单精度浮点;
		单精度浮点 = 单精度浮点;
		双精度浮点 = 单精度浮点;

		// 字符型基本数据 = 双精度浮点;
		// 短整型基本数据 = 双精度浮点;
		// 整型基本数据 = 双精度浮点;
		// 长整型基本数据 = 双精度浮点;
		// 单精度浮点 = 双精度浮点;
		双精度浮点 = 双精度浮点;
	}

	/***
	 * 注意引用类型相互直接无法直接转换(强制转换也不可以的哦)。
	 * 
	 * （1） 使用很多引用类型提供的方法可以转换为许多基本类型，然后基本类型再到对应的引用类型是不需要强制转换的。
	 * 
	 * （2） 强制转换为对应的基本类型（仍然需要注意是从低精度到高精度）。注意引用类型直接无法强制转换。 这种情况无法从高精度到低精度转换。
	 */
	public void 引用数据类型转换_以及引用和基本数据类型之间的转换() {
		Character 字符型引用数据 = ' ';
		Short 短整型引用数据 = 48;
		Integer 整型引用数据 = 48;
		Long 长整型引用数据 = 48L;// 首先是此处注意，引用类型数据Long是无法使用int字面量赋值的。
		Float 单精度浮点引用 = 1.2F;
		Double 双精度浮点引用 = 2.4;

		字符型引用数据 = 字符型引用数据;
		// 短整型引用数据 = 字符型引用数据;
		整型引用数据 = (int) 字符型引用数据;
		长整型引用数据 = (long) 字符型引用数据;
		单精度浮点引用 = (float) 字符型引用数据;
		双精度浮点引用 = (double) 字符型引用数据;

		// 字符型引用数据 = 短整型引用数据;
		短整型引用数据 = 短整型引用数据;
		整型引用数据 = (int) 短整型引用数据;
		长整型引用数据 = (long) 短整型引用数据;
		单精度浮点引用 = (float) 短整型引用数据;
		双精度浮点引用 = (double) 短整型引用数据;

		// 字符型引用数据 = 长整型引用数据;
		// 短整型引用数据 = 长整型引用数据;
		// 整型引用数据 = 长整型引用数据;
		长整型引用数据 = 长整型引用数据;
		单精度浮点引用 = 长整型引用数据.floatValue();
		双精度浮点引用 = 长整型引用数据.doubleValue();

		// 字符型引用数据 = 单精度浮点;
		// 短整型引用数据 = 单精度浮点;
		// 整型引用数据 = 单精度浮点;
		// 长整型引用数据 = 单精度浮点;
		单精度浮点引用 = 单精度浮点引用;
		双精度浮点引用 = 单精度浮点引用.doubleValue();

		// 字符型引用数据 = 双精度浮点;
		// 短整型引用数据 = 双精度浮点;
		// 整型引用数据 = 双精度浮点;
		// 长整型引用数据 = 双精度浮点;
		// 单精度浮点 = 双精度浮点;
		双精度浮点引用 = 双精度浮点引用;
	}

	public void 特殊类型null() {
		int a = (Integer) null;// java.lang.NullPointerException
		int[] b = null;
		int c = b[0];// java.lang.NullPointerException
		// 注意null是引用类型，int[]类型也是引用类型哦。
		// 赋值给基本类型需要强制转换。

	}

}
