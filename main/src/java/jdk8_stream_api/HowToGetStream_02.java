package jdk8_stream_api;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

import org.junit.Test;

public class HowToGetStream_02 {

	/***
	 * 讲了这么多Introduction，那么如何获取Stream呢？
	 */
	// 1通过Stream接口的静态工厂方法（注意：Java8里接口可以带静态方法）；
	// 2通过Collection接口的 默认方法 Default method(新特性) :stream()
	// stream方法把一个Collection对象转换成Stream
	// 默认方式就是接口中的一个带有实现的方法
	// 下面是一些例子

	/***
	 * 通过Stream的静态工厂方法<br/>
	 * 1: public static<T> Stream<T> of(T t)<br/>
	 * 2: public static<T> Stream<T> of(T... values)
	 */
	@Test
	public void test1() {
		Stream<String> stream = Stream.of("hello");
		stream.forEach((e) -> System.out.println(e));

		System.out.println("------");

		stream = Stream.of("hello", "world");
		Stream<String> peek = stream.peek((e) -> System.out.println(e));

		System.out.println("------");

		peek.forEach(System.out::println);

		// 注意，这个结果会很出乎意料。
		// 原因是如果peek那句不接受返回，那么stream.peek是无输出的
		// 即使接收了，去掉最好一句forEach也是peek无输出
		// 然而，带上forEach这句，输出的是hello,hello,world,world

		// 个人大概理解是，peek的操作不马上执行，当peek操作返回的stream（此处为peek）时候才会导致第一次的peek被执行？
		// --->>哈哈，后边的测试有了这个问题答案。
		// peek本身从注释中就知道是为了debug
		// 也即是说stream操作过程中间结果可以通过peek进行输出，给一个syso操作。
		// 但是呢，这个输出是在stream中元素被消费的时候才触发的。

		// 上边的代码中真正消费的时候也就是peek.forEach的时候
		// 上边代码特殊之处还在于，forEach本身是为了输出，而peek我们也进行了输出
		// 而stream中元素是一个一个被消费的。
		// 所以peek的结果和forEach的结果是一个一个对应输出的
		// 而不是peek结果输出完毕之后才能输出forEach结果

		// 这都不是事。。。请看test6
		// peek这功能真尼玛强大。
		// stream的计算竟然优化这么好，比如你又limit，skip等操作的话
		// 即使你先peek，后又limit等
		// peek操作也不会输出全部
		// --->>>
		// 但是呢？？？？
		// 仔细想想，这个很奇怪吗？真不奇怪。
		// 为什么呢？仔细理解，peek的操作执行时机：就是元素被消费的时候
		// skip和limit的时候元素还没被消费，自然peek是不会执行的
		// 真正消费的时候元素本身就不多了，当然peek执行的次数也不多

	}

	/***
	 * generator方法<br/>
	 * Stream接口的静态方法generator<br/>
	 * public static<T> Stream<T> generate(Supplier<T> s)
	 */
	@Test
	public void test2() {
		Stream<String> s = Stream.generate(() -> new String("hello"));

		// System.out.println(s.count());
		// 注意上面这句不行，无输出。为什么呢？因为死循环，根本count不过来。

		// s.forEach((e) -> System.out.print(e + ", "));
		// 那这句呢？输出倒是有了，不过还是死循环，不断输出，直接卡死。
		// 为什么呢？答案就在下面这段注释中，摘自generator的注释。

		// Returns an infinite sequential unordered stream where each element is
		// generated by the provided {@code Supplier}. This is suitable for
		// generating constant streams, streams of random elements, etc.

		// 恍然大悟？infinite啊，麻蛋。
		// 这有啥意义呢？一般没啥意义，但是注意，这种东西都是懒计算，不是创建的时候计算以及分配空间等。
		// 否则刚创建的时候电脑就崩溃了，无限懂吗？就是全世界所有内存加起来也不叫无限。

		// 所以这种东西一般如下使用：
		// 通过limit方法限制个数
		s.limit(5);

		// s.limit(5);
		// 此处顺便再科普一个知识，就是任何一个Stream只能操作一次。
		// 每次操作之后会返回一个新的Stream。
		// 所以链式操作实际每个中间结果Stream最多可能被操作一次哦。
		// 所以如果去掉上边这个注释，俩次调用limit都会出错，报错如下：
		// java.lang.IllegalStateException: stream has already been operated
		// upon or closed
		// 是所有操作都是出现一次，相互之间也是一次，不是同一操作只能一次哦。
		// 好吧。原来如此。继续吧。

		// s.forEach((e) -> System.out.print(e + ", "));
		// 八嘎，刚刚说了只能操作一次，以及limit了，就不能forEach了。
		// 可惜，刚刚limit的时候忘记了记录返回值。算了这个就不做了。自己实现吧。

		// 下面补充三种不同写法
		// 具体不懂得话看函数式接口的项目，各种实现方式。
		// // 1
		// Stream.generate(new Supplier<Double>() {
		// @Override
		// public Double get() {
		// return Math.random();
		// }
		// });
		// // 2
		// Stream.generate(() -> Math.random());
		// // 3
		// Stream.generate(Math::random);

	}

	/***
	 * 通过Stream的iterate静态方法:<br/>
	 * public static<T> Stream<T> <br/>
	 * iterate(final T seed,final UnaryOperator<T> f) <br/>
	 * UnaryOperator还记的嘛？<br/>
	 * 首先是操作符，操作符是函数的子接口，所以肯定是函数（有输出）<br/>
	 * 操作符特殊就是输入和输出的类型一致。<br/>
	 * 一元说明是一个输入。<br/>
	 */
	@Test
	public void test3() {
		Stream<Integer> s = Stream.iterate(1, (e) -> e + 1);
		// 注意s还是无限的哦
		// 1 首先通过limit进行数量限制
		// 2 其次，求个和玩吧，结果sum竟然不能用？why？因为Stream不知道是否能计算。
		// 所以sum当然不能在这提供，必须在IntStream等能计算的Stream中提供。
		// 所以进行个转换即可。如下：
		System.out.println(s.limit(5).mapToInt(e -> e).sum());

	}

	/***
	 * 1<br/>
	 * 所有Collection的子类都可以通过stream方法获取stream。<br/>
	 * default Stream<E> stream(); 2 <br/>
	 * Arrays.stream(T[] array) 方法，等几个类似方法。
	 */
	@Test
	public void test4() {
		System.out.println(Arrays.asList(new Integer[] { 1, 2, 3, 4, 5 }).stream().mapToInt(e -> e).sum());
		System.out.println(Arrays.stream(new Integer[] { 1, 2, 3, 4, 5 }).mapToInt(e -> e).sum());
	}

	// 哦了，此处测试一下flapMap功能
	@Test
	public void test5() {
		Integer sum = null;
		// 实现1*2+3*4+5*6+7*8+9*10的计算
		// 1
		sum = null;
		sum = Arrays.asList("1 2", "3 4", "5 6", "7 8", "9 10")//
				.stream()//
				.mapToInt(//
						e -> {
							String[] splits = e.split(" ");
							int a = Integer.parseInt(splits[0]);
							int b = Integer.parseInt(splits[1]);
							return a * b;
						})
				.sum();
		System.out.println(sum);// 190

		// 2
		// 注意这些方法本质都一样，只是1中用一个map，2中使用多次map。
		sum = null;
		sum = Arrays.asList("1 2", "3 4", "5 6", "7 8", "9 10")//
				.stream()//
				.map(e -> e.split(" "))//
				.map(e -> new int[] { Integer.parseInt(e[0]), Integer.parseInt(e[1]) })//
				.map(e -> e[0] * e[1])//
				.mapToInt(e -> e)//
				.sum();
		System.out.println(sum);// 190

		// 3
		// 这个方法用用flapMap试试
		sum = null;
		sum = Arrays.asList("1 2", "3 4", "5 6", "7 8", "9 10")//
				.stream()//
				.flatMap(e -> Arrays.stream(e.split(" ")))//
				// .forEach(e->System.out.println(e));
				// 经过这步后，元素变成了 1,2,3,4,5,6,7,8,9,10的字符串.
				// 所以flapMap功能就是，将原先元素拆解开，每个元素拆成多个（此处表现为一个stream）。
				// 所以需要的参数是： T -> Stream<R>
				// flapMap的返回值还是 Stream<R>，这个Stream是每个元素得到的stream的并集。
				.mapToInt(Integer::parseInt)//
				// 首先转换成int stream
				// 然后随便找个办法求解，比如下面通过去除偶数，然后只计算单数方式：
				.filter(e -> e % 2 != 0)//
				.map(e -> e * (e + 1))//
				.sum();
		System.out.println(sum);// 190

	}

	/***
	 * 一个综合例子<br/>
	 * 以及从中发现的关于peek的大秘密。
	 */
	@Test
	public void test6() {
		List<Integer> nums = Arrays.asList(1, 1, null, 2, 3, 4, null, 5, 6, 7, 8, 9, 10);
		System.out.println(nums);
		System.out.println(nums.stream().count());// 13
		System.out.println(System.lineSeparator() + System.lineSeparator());
		int sum = nums.stream()//
				.filter(num -> num != null)// 1,1,2,3,4,5,6
				.distinct()// 1,2,3,4,5,6
				.mapToInt(num -> num * 2)// 2,4,6,8,10,12
				.skip(2)//// 6,8,10,12
				.limit(4)// 6,8,10,12
				.peek(System.out::println)// 注意，可以上下移动这一行代码debug中间结果。
				.sum();
		System.out.println("sum is:" + sum);
		/***
		 * 根据结果发现很奇怪的事情，就是peek的输出有点出乎意料？<br/>
		 * 解释：严格理解，peek的执行时机是stream中一个元素被消费的时候，会针对这个元素执行一次peek指定的操作<br/>
		 * 也就是说stream被消费时候，元素可能已经不是原始的nums，自然不是输出全部了。
		 */

	}

}
